# 内存分配与回收策略

Java 技术体系的自动管理，最根本的目标是自动化地解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。

对象的内存分配，首先是在堆上分配（也可能是经过即时编译后备拆散为标量类型，间接地分配在栈上）。在金典分代的设计中，新生对象通过分配在新生代上，少数情况下（对象大小超过阈值）也可能会直接分配在老年代。对象分配的规则并不固定，《Java虚拟机规范》并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是那种垃圾收集器，以及虚拟机中内存相关的参数的设定。

### 对象优先在Eden 分配

大多数情况下，对象在新生代Eden 区中分配，当Eden 区没有足够的空间进行分配时，虚拟机将发起一次 Minor GC。

### 大对象直接进入老年代

大对象就是指需要大量连续内存空间的 Java 对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的大数组， 如 byte[] 数组就是典型的大对象。

### 长期存活的对象进去老年代

HotSpot 虚拟机中大多数收集器都采用了分代收集来管理堆内存，那内存回收时候就必须能决策哪些存活动对象放在新生代，哪些存活对象放在老年代中。

虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden 区里诞生，如果经过第一次Minor GC 后仍然存活，并且能被Survivor 容纳的话，该对象会被移动到Survivor 空间中，并且将对象年龄设为1 岁。对象在Survivor 区中每熬过一次 Minor GC ，你那里就增加1 岁，当它的年龄增加到一定程度（默认 15）， 就会进入老年代。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold 设置。

### 动态对象年龄判断

为了更好地适应不同程序的存储状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到 -XX:MaxTenuringThrshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象的大小的总和大于 Survivor 空间的一半，年龄大小或等于该年龄的对象就可以直接进入老年代，无须等到 -XX:MaxTenuringThreshold 中要求的年龄。

### 空间分配担保

在发生Mionr GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败（Handle Promotion Failure）; 如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均值大小，如果大于，将尝试一次 Minor GC , 尽管这次 Minoc GC 是有风险；如果小于，或者-XX:HandlePromotionFailure 设置不允许冒险，拿着时就要改为进行一次 Full GC。

