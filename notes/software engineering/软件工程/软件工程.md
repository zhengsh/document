
### 软件开发方法
#### 软件开发方法
##### 结构化法 （瀑布模型）
  面向过程的开发方法，强调过程。（小、更具体瀑布模型），统一过程（UP）
* 用户至上
* 严格区分工作阶段，每个阶段有任务与成果 （流程固话、修改起来比较麻烦）
* 强调系统开发过程的整体性和全局性
* 系统开发过程化，文档资料标准化
* **自顶向下**，逐步分解（求精）
* 考点
  **新项目域过去成功开发过的一个类似项目，就应该使用瀑布模型进行项目开发，因为已经有以前开发的经验和积累的软件模块，这些都可以应用到新项目中。**

##### 原型法 （仅针对需求分析阶段）
  适用于续期不明确的项目
  原型分两个阶段：第一个阶段会用原型来获取需求，第二个阶段，再把系统开发出来。瀑布模型来完成）
  
  快速原型模型（抛弃型）
  演化模型
  
* 适用于需求不明确的开发
* 包括抛弃原型和进化型原型

##### 面向对象方法 （系统的元素跟实现生活相结合）
  模拟现实社会，自底向上
* 更好的复用性
* 关键在于建立一个全面、合理、统一的模型
* 分析、设计、实现三个阶段、界限不明确

##### 面向服务的方法 （构件）
* SO方法有三个主要的抽象级别：操作、服务、业务流程 
* SOAD分为三个层次：基础设计层（底层服务构件）、应用结构层（服务之间的接口给和服务级协定）
和业务组织层（业务流程建模和服务流程编排）
* 服务建模：分为服务发现、服务规约和服务实现三个阶段

总结：
 SOA: 面向服务的架构
 WEB服务
 ESB企业服务总线
 

#### 软件开发模型

##### 瀑布模型
  结构化开发方法
* 软件设计
   
* 需求分析
  和用户有非常多的接触
* 软件设计

* 程序编码

* 软件测试

* 运行维护

阶段明析，适合于需求明确的项目


##### 演化模型

##### 增量模型

##### 螺旋模型 （属于结构化的开发方法）
  **原型模型**为基础，配合加上瀑布模型
* 制定计划
* 风险分析DSSA
* 实施工程
* 客户评估

##### 快速原型模型

* RAD 快速应用开发模型 PB Delphi
  * CBSD 基于构件的开发模型
  * SDLC 瀑布模型


##### 喷泉模型
  面向对象的开发模型

* 面向对象

##### V模型

测试模型，测试贯穿始终（敏捷开发-测试驱动）

* 需求分析
* 概要设计
* 详细设计
* 编码
* 单元测试
* 集成测试
* 系统测试
* 验收测试（确认测试）

需求分析=> 测试计划
概要设计=> 系统测试、集成测试

##### 构件组装模型

* 需求分析和定义
* 软件架构设计
* 构件库的建立（构件库 => 构件获取、构件管理）（构件标准 => CORBA、 COM/DCOM、EJB）
* 应用软件构建
* 测试和发布

* 系统构件组装分为三个层次：定制（Customization）、集成（Integration）、拓展（Extension）

其他： MDA 模型启动架构 TDD 领域驱动


##### 统一过程(UP)

用例驱动、以架构为中心、迭代和增量，基于构件的开发方法

* 初始 （开发模型、开发方法、开发过程方法）
**确定项目范围和边界**
   * 项目范围定义输入包括：
     * 项目章程
     * 项目范围管理计划
     * 组织过程资产
     * 批准的变更申请
* 识别系统的关键用例
* 展示系统的候选架构
* 估计项目费用和时间
* 评估项目风险

* 细化（完成架构设计）、 非常重要
* 分析系统问题领域
**建立软件架构基础**
* 淘汰最高风险元素

* 构建 
* 开发剩余的构件
**构件组装与调试**

* 交付
* 进行β测试
  * α:开发环境，用户来做的
  * β:用户环境，用户来做的
**制作发布版本**
* 用户文档定稿
* 确认新系统
* 培训、调整产品

##### 敏捷方法
  
  
* 自适应开发
* 水晶方法
* 特征驱动开发
* 极限编程
* 基本原则

    1. 短平快的会议
    2. 小型版本发布
    3. 较少的文档
    4. 合作为重
    5. 客户直接参与
    6. 自动化测试
    7. 适应性计划调整
    8. 结对编程
    9. 测试驱动开发
    10. 持续集成
    11. 重构 
* 大价值观
    1. 沟通
    2. 简单
    3. 反馈
    4. 勇气
* 5大原则
    1. 快速反馈
    2. 简单性假设
    3. 逐步修改
    4. 提倡更改
    5. 优质工作
* 12 大最佳实践

|  -     |      -      | 
| :------| :------     | 
| 计划游戏 | 结对编程     | 
| 小型发布 |集体代码所有制 |
| 隐喻    |持续集成      |
| 简单设计 |每周工作40小时 |
| 测试先行 |现场客户      |
| 重构    |编码标准      |

* 敏捷开发方法（核心）


XP (Extreme Programming, 极限编程) 在所有的敏捷型方法中，XP是最
引人瞩目的。它源于Smalltask圈子，特别Kent Beck 和 Ward Cunningham 
在20世纪80年代末的密切合作。XP在一些对**费用控制严格的公司中使用**，已经被证明**非常有效**的

Cockburn 的水晶系列方法， 水晶系列方法是由Alistair Cockburn 提出的。他与XP方法一样
都是以人为中西你的理念，但是在实践上有所不同。Alistair 考虑到人们一般很难严格遵循一个纪律
约束很强的过程，因此，与XP在高度纪律性不同，Alistair 探索了 **用最少纪律约束而任能成功的的方法**。
从而在产出效率与易于运作上达到一种平衡。也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够
接受并遵循它。

开放式源码，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是
**程序开发人员在地域上分布很广**。这使得它和其他敏捷方法不同，因为一般的冥界方法都强调项目组成员在同一地点工作，
开放源码的一个突出特点就是查错排障（debug）的高度并行性，任何人发现错误都可将改正源码的“补丁”文件发给维护者
然后由维护者将这些“补丁”或是新增的代码并入源码库


SCRUM, SCRUM 已经出现很久了，像前面所论及的方法一样，该方法强调这样一个事实，即
**明确定义了的可重复的方法过程**只限于在明确定义了的可重复的环境中，为明确定了了的可重复的人员所用，去
解决明确定义了的可重复的问题

Coad 的功能驱动方法（FDD-Feature Driven Development）
FDD 是由Jeff De Luca 和大师 Peter Coad 提出来的，像其他方法一样。它致力于短时期的迭代阶段和可见可用
的功能。在FDD中，一个迭代周期一般是2周。
在FDD中，编程开发人员分成两类 **首席程序员和“类”程序员**（class owner）,首席程序员是最富有经验的
开发人员，他们是项目的协调者，设计者和指导者，而“类”程序员主要是做源码编写

ASD方法，ASD（Adaptive Software Development）方法是由Jim Highsmith 提出，其核心是三个非线性的，
重叠的开发阶段：**猜测、合作与学习**
 
#### 构件与软件重用


#### 逆向工程


阶段：现有系统  -> 再工程 -> 新系统
     逆向工程  -> 考虑新需求 -> 正向工程

* 实现级
  包括程序的抽象语法树、符号表、过程的设计表示
* 结构级
  包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构
* 功能级
  包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型
* 领域级
  包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型
  


#### 净室软件工程


* 净室即无尘室、洁净室。也就是一个受控污染级别的环境
* 使用盒结构规约（或形式化方法）进行分析和设计模型，并且强调将正确性验证，而不是测试，
作为发现和消除错误的主要机制
* 使用统计的测试来获取认证被交付的软件的可靠性必须的出错率信息


### 需求工程
#### 概述
软件需求是指用户对系统的在功能、行为、性能、设计的约束等方面的期望
软甲你需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他
正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明

需求开发（技术）：需求获取、需求分析、需求定义（严格定义、原型法）、需求验证（需求基线）
需求管理（管理）：变更控制（需求基线）、版本控制、需求跟踪、需求状态跟踪

##### 需求获取

需求获取方法：收集资料、联合讨论会、用户访谈、书面调查、现场观摩、参加业务实践、阅读历史文档、朝阳调查

需求分类： 业务需求（总体的、目标性的）、用户需求（用户视角的内容）、系统需求、功能需求、
性能需求（非功能）、设计约束（J2EE、MySQL、Linux）、基本需求（用户明确提出来的）、
期望需求（隐含需求）、兴奋需求（不要去做）


##### 需求分析

##### 需求说明书
* 软件需求说明书包括：信息流和界面，功能需求，设计要求和限制，测试准则和质量保证要求

##### 需求分析-SA

数据字典数据的解释说明的，UML多种方法转换过来

* 数据字典 
  * 数据元素
  * 数据结构
  * 数据流
  * 数据存储
  * 加工逻辑
  * 外部实体

* 行为模型
  * 状态准换图（SA）
    * 状态 （初态、终态）
    * 事件 

* 数据模型
  * E-R 图
    * 实体
    * 联系

* 功能模型
  * 数据图流图（DFD）
    * 数据流
    * 加工
    * 数据存储
    * 外部实体
  *顶层数据流图
  
##### 需求分析-OOA

* 对象
* 类（实体类、边界类、控制类）
  * ER 实体联系图
* 抽象
* 封装
* 继承与泛化
  * 父子关系 一般与特殊
* 多态
* 接口
  * 一种特殊的类
* 消息
* 组件
* 模式和复用

**实体类**映射需求中每个实体，实体类保存需要存储在永久存储体重的信息，例如：在线教育平台系统可以提取出学院类的课程类，他们都属于实体类

**控制类**适用于控制用例工作的类，一般是由动宾结构的短语（"动词+名称" 或 "名词" + "动词"）转化来的名词，例如：用例 "身份验证"，
可以对应一个控制器类它提供了与 "身份验证器", 它提供了与身份验证相关的所有操作。

**边界类**用于封装在用例内、外流动的信息或数据流。边界类位于系统与外界的交接处，包括所有窗体、报表、打印机、和扫描仪等硬件的接口，
以及与其他系统的接口

补充：MVC 表示层的框架


* 构造块
  * 事物
    * 结构事物：最静态的部分。包括：类、接口、协作、用例、活动、构件和节点
    * 行为事物：代表时间和空间上的动作。包括：消息、动作次序、连接。
    * 分组事物：看成是个盒子，如：包、构件。
    * 注释事物：UML模型的解释部分。描述、说明和标注模型的元素
  * 关系
    * 依赖关系：一个事物发生变化影响另一个事物
    * 泛化关系：特殊/一般关系
    * 关联关系：描述了一组链，链式对象之间的连接。
      * 聚合关系：整体与部分生命周期不同
      * 组合关系：整体与部分生命周期相同
  * 图
* 规则
* 公共机制
  * 规格说明：事物语意的细节描述。它是模型真正的核心
  * 修饰：通过修饰来表达更多的信息
  * 公共分类：类与对象、接口与实现
  * 拓展机制：允许添加新的规则
  

* UML
  * UML 2.0
    * 结构图（静态图）
      * 类图
      * 对象图
      * 包图
        **若干个软件元素打包，展示整体包与包之间的联系，偏上层的结构** 
        **表示软件体系结构图**
      * 组合结构图
      * 构件图
        **部署图：软硬件之间映射**
      * 制品图
      
    * 行为图（动态图）代表交互关系    
      * **用例图：系统与外部参与者的交互**
        * 用例图描述一组用例、参与者以及他们之间的关系
        * 用户角度描述系统功能
        * 参与者是外部触发因素（包括用户、组织、外部系统、时间）
        * 用例是功能单元
        * 关系包括：
          * 包含关系 （必要的）（使用关系、uses）
          * 拓展关系 （有时用到、就用拓展， 如：取钱打印凭条）
          * 泛化关系 （父子关系，一般特殊的关系)  
        * 用例模型的流程
          * 识别参与者（必须）
          * 合并需求获得用例（必须）
          * 细化用例描述（必须）
          * 调整用例模型（可选）          
      * <交互>**顺序图（时序图）：强调按时间顺序**
      * <交互>**通信图（协作图）**
      * <交互>定时图
      * 状态图：状态转换变迁
      * **活动图：类似程序流程图，并行行为**
      * 交互概览图
* 交互图表示的用例实现，完整精确的类图，针对复杂的对象和状态图用以描述流程化处理的活动等。

* OOA-UML—4+1视图
  * 逻辑视图（logical view）(系统功能)
    * 参与者：系统分析、设计人员
    * 类与对象

  * 实现视图 (implementation view) （组件）
    * 参与者：程序员
    * 物理代码文件和组件
    
  * 进程视图 (process view) (并发) (活动图) （开发视图）
    * 参与者：系统集成人员
    * 线程、进程、并发
    
  * 部署视图 (deployment veiw) （）
    * 参与者：系统和网络工程师
    * 软件到硬件的映射
    
  * 用例视图（use-case view）
    * 参与者：最终用户
    * 需求分析模型

#### UML4+1视图 （考点）
* 4+1视图
  * 逻辑视图。模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。
  * 进程视图。是逻辑视图的一次执行实例，描述并发与同步结构
  * 实现视图（开发视图）。基于系统的物理代码的文件和构件进行建模
     * 静态组织结构、支持软件开发的内部需求
  * 部署视图（物理视图）。部署构件、表示软件到硬件的映射和分布结构
  * 用例视图。最基本的需求分析模型

##### 需求分析-OOA

* 用例模型
  * 识别参与者
  * 合并需求获得用例
  * 细化用例描述
    * 用例名称
    * 简要说明
    * 事件流
    * 非功能需求
    * 前置条件
    * 后置条件
    * 拓展点
    * 优先级
  * 调整用例模型
    * 包含关系 （使用关系、uses）
    * 拓展关系
    * 泛化关系

* 分析模型
  * 定义概念类
  * 识别类之间的关系
    * 依赖关系 （）
    * 关联关系
    * 聚合关系
    * 组合关系
    * 泛化关系
    * 实现关系
  * 为类添加职责
  * 建立交互图

#### 类图与对象图

* 类图（class diagram）
  类图描述一组类、接口、协作和他们之间的关系。
* 对象图（object diagram）
  对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照
* 类名，方法名，属性名
* 多重度
* 关系
  辅助记忆：菱形（关联关系），空心箭头（泛化关系）
  * 依赖关系：
    **一个事物发生变化影响另一个事物**
  * 泛化关系：
    **特殊、一般关系**
  * 关联关系：
    **整体和部分**
    * 聚合关系：整体与部分生命周期不同
    * 组合关系：整体与部分生命周期相同
  * 实现关系：
    接口与类之间的关系

#### 顺序图
* 顺序图（sequence diagram, 序列图）。
  顺序图是一种交互图（interaction diagram）,它强调对象之间消息发送的顺序，同时显示对象之间的交互。
  
  用户登录：输入密码 —> 检查登录状态 -> 登录

#### 活动图 （泳道图）
  活动图（activity diagram）。活动图将进程或其他计算结构展示为计算内部一步步的控制流和数据流。
活动图专注于系统的动态视图。对于系统的功能建模和业务流程建模特别重要，并枪挑对象间的控制流程。
  
#### 状态图
  在订单处理的过程中，会员可以点击"取消订单"取消该订单，如果 **支付失败** ， 该订单将被标记为**挂起状态**
,可后续重新支付，如果挂起超过30分钟未支付。系统将自动取消该订单。订单支付成功后，系统判断订单类型。
（1）对于常规订单，标记为**备货状态**，订单信息发送到货运部，完成打包后**交付快递**发货；
（2）对于定制订单，会自动进入定制状态，定制完成后**交付快递**发货。会员在系统点击"收货"按钮变为**收货状态**
,结束整个订单的处理流程。
注意事项：题目描述与图形成对应关系

#### 通信图（协作图）
 通信图(communication diagram)。通信图也是一种交互图，它强调收发消息的对象或参与者的结构组织。
顺序图和通讯图表达了类似的基本概念。但他们表达的概念不同，顺序图强调的是时序，通讯图强调的事对象之间的组织结构
（关系）。
* 问题：时序图与通信图的区别
  共同点：时序图与协作图均显示了对象之间的交互关系
  不同点：时序图强调的是对象交互的啥时间次序，通信图强调的是对象之间的组织结构。

#### 需求定义
  用结构化和知道让语言编写文本型文档、建立图形化模型、编写形式化规格说明
* 严格定义法
  * 所有需求都能够被预先定义
  * 开发人员与用户之间能够准确而清晰地交流
  * 采用图形/文字可以充分体现最终系统
  
* 原型法
  * 并非所有的需求都能在开发前辈准确的说明
  * 项目参加者之间通常都存在交流上的困难
  * 需要实际的、可供用户参与的系统模型。
  * 有合适的系统开发环境
  * 反复是完全需要和值得提倡的，需求一旦确定，就应遵从严格的方法
  
#### 需求工程-需求开发-需求验证
* 需求验证
 * 需求评审
   * 正式评审
   * 非正式评审
   
* 用户前置确认
* 验收标准之一

#### 需求工程-需求管理-定义需求基线

#### 需求工程-需求管理-需求跟踪
* 工具
  * 需求跟踪矩阵
* 变更控制 （基线形成后，要走变化，必须走变更流程）
  * 变更申请
  * 变更评估
  * 变更决策
  * 变更实施
  * 变更验证
  * 沟通存档
* 软件系统建模（不局限于计算机化系统）
  逆向工程
  * 现有系统
  * 物理系统（模型化）
  * 物理模型（抽象画）
  * 逻辑模型 
  调整/优化
  
  正向工程
  * 逻辑模型（需求分析）（结构化的建模、面向对象的建模）
  * 物理模型（软件设计）（实例化）
  * 物理系统（具体化）
  * 新系统
  
## 系统设计
* 处理流程设计
* 人机界面设计
* 结构化设计
* 面向对象设计
  
### 系统设计-人机界面设计
* 置于用户控制之下
  * 以不强迫用户进入不必要的或不希望的动作的方式来定义交互方式
  * 提供灵活的交互
  * 允许用户交互可以被中断和撤销
  * 当技能级别增加时可以使交互流水化并允许定制交互
  * 使用户格力内部技术细节
  * 设计应允许用户和出现在屏幕上的对象直接交互
* 减少用户的记忆负担
  * 减少对短期记忆的要求
  * 建立有意义的缺省
  * 定义直觉性的捷径
  * 界面的视觉布局应该基于真实世界的隐喻
  * 以不断进展的方式揭示信息
* 保持界面的一致性
  * 允许用户将单亲啊任务放入有意义的语境
  * 在应用系列内保持一致性
  * 如过去的交互模型已建立起了用户期望，除非有迫不得已的理由，不要去改它
  
### 系统设计-结构化设计
* 概要设计（外部设计）
  * 模块划分（子系统划分）
  * 模块之间衔接的设计
  * 软件概要设计包括设计软件的结构、确定系统功能模块以及其相互关系，主要采用：模块**结构图、层次图、HIPO图**来描述程序的结构
* 详细设计（内部设计）
  * 模块内部设计
* 原则
  * 抽象化
  * 自顶而下、逐步求精
  * 信息隐蔽
  * 模块独立（高内聚、低耦合）
    * 模块内的紧密度
    * 模块间的关联
* 总结
  * 保持模块的大小适中
  * 尽可能减少调用的深度
  * 多扇入、少扇出
  * 单入口、单出口
  * 模块的作用域应该在模块内
  * 功能应该是可预测的
* 拓展
  * SOA面向服务的架构 

#### 系统设计-面向对象设计-设计原则
* 单一职责原则：设计目的单一的类
  * 高内聚
  
* 开放-封闭原则：对拓展开放，对修改封闭
  * 修改一个BUG容易导致新的错误
  
* 李氏（Liskov）替换原则：子类可以代替父类

* 依赖倒置原则：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程

* 接口隔离原则：使用多个专门的接口比使用单一的总接口好

* 组合重用原则：尽量使用组合，而不是继承关系达到重用的目的

* 迪米特（Demeter）原则（最少只是法则）：一个对象应当对其他对象有尽可能少的了解。
迪米特法则的应用准则：

  * 在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。
  * 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界简介访问自己的属性。
  * 在类的设计上，只要有可能，一个类应当设计成不变类。
  * 在对其它对象的引用上，一个类对其他的对象的引用应该降到最低。
  

#### 系统设计-面向对象设计-设计模式概念

* 架构模式：软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策
* 设计模式：主要关注软件系统的设计，与具体的实现语言无关
* 惯用法：使最低层的模式，关注软件系统嗯设计实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。
每种编程语言都有它自己特定的模式，即语言的惯用法，例如引用-计数就是C++语言中的惯用法。

设计模式（Design pattern）是一套反复被使用、多数人知晓的、经过分类编写目的、代码设计经验的总结。谁模式是为了可重用代码、让代码更容易被他人理解、
保证代码可靠性。那么重复利用代码要求解决的是同一类。同一类可以有多种表现形式。

* 设计模式的特征：
  * 设计模式是一些优雅的解决方案，是在大量实践经验的基础上提出来的。
  * 设计模式通常不依赖于特定的系统类型、程序设计语言或应用领域，他们是通用的 。
  * 设计模式再实际系统和面向对象系统中得到了广泛应用，他们并不仅仅停留在理论上。
  * 设计模式通常都非常简单， 只涉及到很少的一些类，为了构件更多复杂的解决方案，可以把不同的设计模式与应用代码结合或者混合使用。
  * 设计模式的建档方式使他们非常容易使用，因此可方便用于任何适宜的系统。
  * 面向对象：设计模式是用最少的面向对象机制如类、对象、多态等构造的。许多模式特别强调了某些面向对象设计擅长的领域，如, 区分接口的实现、
降低各个部分之间的依赖性、隔离硬件和软件等。

#### 系统设计-面向对象设计-设计模式的分类

* 创建型模式：创建对象
  * <u>工厂方法（factory method）模式</u>
  * 抽象方法（abstract method）模式
  * 原型模式（prototype method）模式
  * 单例模式（singleton）模式
  * 构建器（builder）模式
  
* 结构型模式：更大的结构
  * **<u>适配器（adapter）模式</u>**
  * **桥接（bridge）模式v
  * **组合（composite）模式**
  * **装饰（decorator）模式**
  * 外观（facade）模式
  * 享元（flyweight）模式
  * 代理（proxy）模式
  
* 行为模式：交互及职责分配
  * **职责链（chain of responsibility） 模式**
  * **命令（command） 模式**
  * <u>解释器（interpreter）模式</u>
  * 迭代器（iterator）模式
  * **中介者（mediator）模式**
  * 备忘录（memento）模式
  * **观察者（observer）模式**
  * **状态（state）模式**
  * **策略（strategy）模式**
  * <u>模板方法（template method）模式</u>
  * 访问者（visitor）模式

* 说明

  有下划线的表示既可以是类模式，也可以是对象模式，
无下划线的表示只能是对象模式

* 常见考点
  * ***设计模式的分类***
  * ***设计模式的应用场景***
  * ***UML图***


#### 系统设计-面向对象设计-创建性模式

* Abstract Factory 抽象工厂模式

  提供了一个接口，可以创建一系列相关或相互依赖的对象
, 而无需指定他们具体的类，***生产成系列对象***

* Builder 构建器模式

  将一个复杂的表示与其构造相分离，使得相同的构件过程能够得出不同的表示
***复杂对象构造***

* Factory Method 工厂方法模式

  定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟
***动态生产对象***

* Prototype 原型模式

  用原型实例指定串讲对象的类型，并且通过拷贝这个原型来创建新的对象
***克隆对象***

* Singleton 单例模式

  保证一个类只有一个实例，并且提供一个访问它的全局访问点
***单实例***

#### 系统设计-面向对象设计-结构性模式

* Adapter 适配器模式（电源适配器-充电器）
  将一个类的接口转换为用户希望的得到的另一种接口，它使原本不相容的接口得到协同工作
  转换接口
   
* Bridger 桥接模式
  将类的抽象部分和它的实现部分分离出来，是他们可以独立地变化
  继承树的拆分
  
* Composite 组合模式
  将独享组合成树形结构以表示 "整体-部分" 的层次结构，使得用户对单个对象和组合对象的使用具有一致性
  树形目录结构 
  
  // todo 
  
  
* Decorator 装饰模式
  动态地给一个对象添加一些额外的职责。它提供了用子类拓展功能的一个灵活替代，比派生一个子类更加灵活。
  附加职责
  
* Facade 外观模式
  定义一个高层接口，为子系统的一组接口提供一个一致的外观，从而简化了该子系统的使用
  对外统一接口
  
* Flyweight 享元模式
  提供支持大量细粒度对象共享的有效方法
  汉字编码
  
* Proxy 代理模式
  为其他对象提供一种代理以控制这个对象的访问
  快捷方式

#### 系统设计-面向对象设计-行为模式

* Chain of Responsibility 责任链模式
  通过给多个对象处理请求的机会，较少轻轨的发送者与接受者之间的耦合。将接收对象链接起来，在链中传递请求，知道有一个对象处理这个请求。
  传递职责

* Command 命令模式
  将一个请求封装为一个对象，从而用不同的请求对客户进行参数化，将请求排队或记录日志，支持可撤销的操作。
  记录日志，可撤销
  
* Interpreter 解释器模式
  给定义一种语言，定义他的文法表示，并定义一个解释器该解释器用来根据文法表示解释语言中的句子。
  虚拟机的机制

* Iterator 迭代器模式
  提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。
  数据集
  
* Mediator 中介者模式
  用一个中介对象来封装一系列的对象交互，它使各对象不需要显式地相互调用，从而达到地柔和，还可以独立地改变对象间交互。
  不直接引用
  **强调解耦**

* Memento 备忘录模式
  在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的转台。
  
* Observer 观察者模式
  定义对象间的一种一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都得到通知并自动更新。
  联动，交通灯和汽车之间的联动关系

* State 状态模式
  允许一个对象在其内部状态改变时改变它的行为。
  状态遍为类

* Strategy 策略模式
  定义一系列的算法，把他们一个个封装起来，并且使他们之间可互相替换，从而让算法可以独立于使用它的用户而变化。
  多方案切换

* Template Method 模板方法模式
  定义一个操作中的算法顾家，而将一些步骤延迟到子类中，使得之类可以不改变一个算法的结构可重新定义算法的某些特定步骤。

* Visitor 访问者模式
  表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作。
  数据与操作分离


## 软件测试
### 软件测试-测试类型
* 尽早、不断的进行测试
* 程序员避免测试自己设计的程序
* 既要选择有效、合理的数据，也要选择无效，不合理的数据。
* 修改后应进行回归测试
* 尚未发现的错误数量与该程序已发现错误数成正比

* 动态测试 (计算机执行)
  * 黑盒测试法
    * 等价类划分
    * 边界值分析
    * 错误推测
    * 因果图
    
  * 白盒测试法
    * 基本路径测试
    * 循环覆盖测试
    * 逻辑覆盖测试
      * 语句判断
      * 判定覆盖
      * 条件覆盖
      * 条件判定覆盖
      * 修正的条件判断覆盖
      * 条件组合覆盖
      * 点覆盖
      * 边覆盖
      * 路径覆盖
      
  * 灰盒测试法
* 静态测试（人工检查）
  * 桌前检查
  * 代码审查
  * 代码走查
  
* 测试工具根据哦你工作原理不同可分为静态测试工具和动态测试工具。
  * 静态测试工具是对代码惊醒语法扫描，找到不符合编码规范的地方，根据某种质量模型评价代码的质量，生成系统的调用关系图等。
它直接对代码进行分析，不需要运行代码，也不需要对代码编译链接和生成可执行文件。静态测试工具可以用于对软件需求、结构设计、
详细设计和代码进行评审、走审和审查，也可以用与对软件的复杂度分析、数据流分析、控制流分析和接口分析提供支持。
  * 动态测试工具与静态测试工具不同，它需要运行被测试的系统，并设置探针，向代码生成的可执行文件中插入检测代码，
可以用于对软件的覆盖分析和性能分析。

* 面向对象的单元测试，包括方法层次的测试和类层次、类树层次的测试。
  * 方法层次的测试，单个函数的测试、常用的测试技术：等价类划分测试、组合功能测试、递归函数测试和多态消息测试等。
  * 类层次的测试主要包括：不变式边界测试、模态类测试和非模态类测试。
  * 类树层次的测试主要包括 ：多态服务测试和展平测试
 
 ### 测试分类
 * 软件确认测试是一种针对需求的测试，是用户参与的测试。它主要验证软件功能、性能以及其他特征是否与用户需求一致、
 * 软件确认测试包括：内部确认测试、Alpha, Beta和集成测试

### 软件测试-测试阶段
* 需求分析
* 概要设计
* 编码        
* V模型
* 单元测试
* 集成测试
* 系统测试
* 验收测试 （确认测试）


* 单元测试
  模块测试，模块功能，性能，接口等。
* 集成测试
  模块间的接口。
* 系统测试
  验证软件与需求的一致性，内部确认测试，Alpha测试、Beta测试，验收测试。
* 系统测试
  真实环境下，验证完整的软件配置项能否和系统正确连接。
* 验收测试
  测试软件变更后，变更部分的正确性对变更需求的符合性。
  
### 软件测试-测试阶段2
* 冒烟测试
  * 单元测试
  * 集成测试
    * 一次性组装
    * 增量式组装
      * 自顶向下
      * 自底向上
      * 混合式
  * 确认测试
    * 内部确认测试
    * Alpha 测试
    * Beta 测试
    * 验收测试
  * 系统测试
    * 恢复测试
    * 安全性测试
    * 压力测试 （什么情况下，系统会崩）
    * 性能测试
      * 负载测试 （不同的复杂下的性能）
      * 强度测试 （给你最少的资源看你的表现）
      * 容量测试 （并发量）
    * 可靠性测试
    * 可用性测试
    * 可维护性测试
    * 安装测试
    
### 软件测试-面向对象的测试
* 算法层（单元测试）：包括等价类划分测试、组合功能测试（基于判定表的测试）、递归函数测试和多态消息测试
* 类层（模块测试）：包括不变式边界测试、莫泰类测试和非模态类测试
* 模板层/类树层（集成测试）：包括多态服务测试和展平测试
* 系统层（系统测试）
  
  
* 软件调试
  * 软件调试方法
    * 蛮力法：主要思想是"通过计算机找错误"，低效，耗时
    * 回溯法：从出错处人工沿控制流程往回追踪，直至发现出错的根源。复杂程序由于回溯路径多，难以实施
    * 原因排除法：主要是想使演绎和归纳，用二分法实现
  * 软件调试与测试的区别
    * 测试的目的是找出存在的错误，而调试的目的是定位错误并修改程序以修正错误。
    * 调试使测试之后的活动，测试和调试在目标、方法和思路上都有所不同
    * 测试从一个已知的条件开始，使用预先定义的过程，有预知的结果，调试从一个未知的条件开始，结束的过程不可预计
    * 测试过程可以事先设计，进度可以事先确定，调试不能描述过程或持续时间
    
  * 总结：
    先有测试用例，在执行，用于发现BUG，
    调试是，发现BUG之后，定位，以解决BUG。
    
系统运行与软件维护
* 系统转换计划
* 如那件维护

### 软件维护
* 正确性维护， 开发阶段改正，测试阶段尚未发现
* 适应性维护， 系统发生变化，需要适应新的环境
* 完善性维护， 提出新需求，补充功能，让功能更加强大
* 预防性维护， 补充一些功能，让功能更加强大，比如：网络设计，下个月需要增加一些流量，然后加机器。

### 系统转换计划-遗留系统演化策略
* 集成
  * 高水平、低价值
* 改造 （优化）
  * 高水平、高价值
* 淘汰
  * 低水平、低价值 （很少采用，业务发生根本的变化时，才考虑）
* 继承 （数据结构、业务流程）
  * 低水平、高价值 （业务价值）

* 淘汰策略
遗留系统的技术含量较低，且具有较低的业务价值。对遗留系统的完全淘汰是企业资源的根本浪费。
系统分析师应该善于"变废为宝"，通过对遗留系统功能的理解和借鉴。可以帮助新系统的设计，降低新系统开发的风险。

* 继承策略
遗留系统的技术含量较低，已经满足企业运作的功能或性能要求。单具部署图有极高的商业价值，目前企业的业务尚紧密依赖该习题通。
对这种遗留系统的演化策略为继承。在开发新系统时。需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统
必须并行运行一段时间，在逐渐切换到新系统上

* 改造策略
遗留系统具有较高的月价值，基本上能够满足企业业务运作和决策支持的需要。这种系统可能建成的时间还很短，
这种遗留系统的演化策略为改造。改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有
系统的基础上增加新的应用要求，对遗留系统本本身不做改变，数据模型的改造是指将遗留系统的旧数据模型向新的数据模型的转化。

* 集成策略
遗留系统的技术含量高，但其业务价值较低、只能完成某个部门（或子公司）的业务管理。这种系统在各自的局部领域里工作良好，
但是对于整个企业来说，存在多个这样的系统，不同的系统基于不同的平台、不同的数据模型，形成了一个个信息孤岛。对这种遗留系统的
演化策略为集成。

### 遗留系统-移植过程
* 计划阶段，在计划阶段，要进行现有系统的调查整理，从移植技术，系统内容（是否进行系统提炼等）、系统运行三个方面，探讨如何转为新系统，
决定移植方法，确定**移植共组体制以及移植日程**。
* 准备阶段，在准备阶段要惊醒移植方面的研究，**准备准换所需要的材料，该阶段的作业质量**将对以后的生产效率产生很大的影响。
* 转换阶段，这个阶段是将程序设计和和数据转换成新机器能更具需要共组哦的阶段，提高转换工作的精度，减轻下一阶段的测试负担是提高移植工作效率的基本内容。
* 测试阶段，这个阶段是进行程序单元、工作单元测试的阶段。在本阶段要核实程序能否在新系统中准确地工作。，所以，当有不能准确工作的程序时、就要回到转换阶段重新工作
* 验证阶段，这是俄式完成的程序使新系统工作，最后核实系统，准备正式运行的阶段。

### 系统转换计划-新旧系统的转换策略

* 直接转换 (直接停老系统，切换到新系统)
* 并行转换策略 （一个过渡期，老系统个新系统一起使用）
* 分段转换策略 （全国部署：一个城市一个城市的上）

### 系统转换计划-数据转换与迁移（ETL）
* 抽取
* 转换
* 装载

旧数据库 => 系统切换前通过工具迁移、系统切换前采用手工录入、系统切换后通过新系统生成 => 新数据库

#### 系统运行与维护
* 可维护性
  * 易分析性
  * 易改变性
    * 性能
    * 可用性
    * 安全性
    * 可维护（可修改）
  * 稳定性
  * 易测试性 
    
* 维护类型 
  * 改正性维护 25% （修改BUG）
  * 适应性维护 20% （环境变了）
  * 预防性维护 5%  （针对未来：重构，使得程序更好读，更易理解）
  * 完善性维护 50% （增加功能、增强性能）

  软件维护是生命周期的一个完整部分。可以将软件维护定义为需要提供软件支持的全部活动，
这些活动包括在交付前完成的活动，以及交付后完成的活动，交付前完成的活动包括交付后运行的计划和维护计划等；
交付后的活动包括软件修改、帮助资料等。

### 体系结构演化
体系结构演化使用系统演化步骤去修改应用，以满足新的需求主要包括一下6个步骤：
  * 需求变化归类，
  * 定制体系结构演化计划
  * 修改、增加删除构件
  * 更新构件的相互作用
  * 构件组长域测试
  * 技术评审 

### 软件设计模型
关注：系统整体结构、代码设计、处理过程、数据结构和界面模型等。