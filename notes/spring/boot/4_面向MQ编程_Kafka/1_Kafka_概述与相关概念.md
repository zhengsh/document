# Kafka 概述

### 特征
* 发布订阅基于消息队列
* 实时的方式对事件进行响应
* 分布式的系统中存储内存

### 基于消息队列的编程
* 传统调用， 在应用之间传统应用基于接口协议(http/rpc)直接调用的方式来进行通讯。
  * 缺点: 强耦合
* 解耦， 如果我们通过 MQ 来进行通讯，那么可以做到系统之间的，服务之间不进行直接的调用。
* 缓冲流量，如果请求数量过大的时候 Kafka MQ 可以缓冲流量。做到流量的消峰，保证服务的安全以及临时存储请求。
 

### Kafka API 设计与概念
* 生产者 API 将消息以流的形式传递给一个消息主题（topic）  
* 消费者 API 应用可以以一个或者多个消费终端来订阅消息主题
* 流 API 一个或者多个主题中去消费输入流，然后输出一个或多个输出主题上去生成输出流。可以有效地将输入流转换为输出流。
* 可重用的 API 
* Kafka 是一种跨语言的，高性能的基于TCP的和客户端通讯协议，提供了多种语言的API

### 主题和分区
* 一个主题可以被多个 Consumer 订阅
* 每个主题维护了一个分区（Partition）的日志（Partition）
![avatar](../../../images/spring-boot/kafka_log_anatomy.png)
* 进行分区过后，消息就会均匀的分配到分区（Partition）。
* 分区上消息的顺序是严格的顺序执行。
* 每个分上的每一条消息都会有一个序列ID(sequential id) 称为偏移量（offset）标识这个消息的唯一标志。
* 默认情况下消息都有一个默认的保持时间（retention policy）2天。
* Kafka 性能是一个常量，和数据量无关。
* 如果进行 offset 指定可进行消息的重复消费或者消费指定消息。每个消费者（Consumer）的 offset 都是独立的，不会影响别的消费者 
![avatar](../../../images/spring-boot/kafka_log_consumer.png)
* 一个主题可以有多个分区，作为并行单元，每个分区会受限于托管服务的容量，可以通过添加服务器来水平拓展容量。

### 副本 
* 每个分区都有他的副本， 每个分区都有一个 leader 和多个 follower, 如果 leader 挂掉后会重新选举一个 follower 称为 leader。每一台服务器可以作为一个分区的
laeder 其他分区的 follower。 这样可以保证服务的高可用

### 生产者
* 生产者负责去选择哪个消息分配到哪一个分区，进行负载均衡。也可以通过一些其他算法来实现

### 消费者
* 消费组会通过消费组（group name）名称标识自身，发现主题的每一个消息，会传递给每个消费组的唯一个消费者实例，消费者实例可以位于不同的进程或不同机器上。
* （单播）所有消费者实例位于同一个消费者组，那么它会将消息负载均衡给到每个消费者实例。
* （广播）如果所有的消费者拥有不同的消费者组，那么消息将会被广播到每一个消费者实例。
![avatar](../../../images/spring-boot/kafka_consumer_groups.png)
* 失败容错，在Kafka中是采用日志来进行分区的，以便每个实例分区上都是公平的。Kafka 协议会动态处理维护加入的订阅者实例。如果有新实例加入组，它将接管一些分区，
如果实例下线，那么则将这些分区分配给其他的实例。
* 消费的实现， 通过消息放在日志中。维护分组成员的方式通过Kafka的协议实现。一个新的实例会占据一个分区， 每个分区会保证顺序，跨越分区消息的顺序不是有序的

### 保证
* 生产者发生的消息将会按照发送顺序进行追加，如果 M1 和 M2 由同一个发布者发布那么。M1 的 offset 比 M2 小并且日志更靠前面。保证日志严格有序。 
* 消费者看到的消息的顺序，与日志的存储顺序
* 对于主题会有N个副本，最多容忍 N-1 个副本崩溃，消息是不会丢失的。

### Kafka 消息系统
* 对比传统消息系统，传统消息模型：排队（queuing）和 发布-订阅（publish-subscribe）。队列这种的消息系统中，消费者的池，可以从一个服务中去读取
并且每一个记录都会进入到一个记录中；发布订阅的模型中，广播给所有的消费者。两种模型各有利弊
* 队列模型，可以在多台 consumers 实例上进行处理进行可伸缩。
* 发布订阅模型，可以广播给多个订阅者，不能进行可伸缩，因为每个消息都会进入每个实例中。
* consumers group 对这两种模型进行了泛化，可以在一个进程的集合上进行处理，对于发布订阅模型，可以发布到多个 consumers group。 Kafka 的
优势在于每个 Topic 都有一个
* Kafka 对比传统队列有一个消息顺序的保证

* 多个消息进行顺序处理。不过服务器按照顺序进行分发和处理，但是消息会按照异步的方式来传递给不同的consumers，但是消息会异步的发送给消费者，
那么记录的顺序，在并行消费的场景消失。

* 通常会通过 work around 的方式来解决，采用一种排他的消费者"exclusive consumer"。在分区的主题中，可以在负载均衡的保证。指定分派的的
分区在 Topic 中。

* 通过分配指定主题（topic）中的分区(partition) 指定给消费者组中的消费组的一个消费者来进行消费。这个样可以保证，consumer 就是唯一的一个
读取者而且按照顺序来读取。

* 由于很多的分区存在，这个会平衡很多消费者实例来进行负载均衡。消费者组的实例个数不能比分区的个数多。

### Kafka 数据存储系统
* Kafka 允许生产者返回 ack 来保证消息写入成功，且持久化。
* Kafka 可以作为一种数据存储系统、

### Kafka 流式数据处理
* 数据处理器可以持续的接受数据处理流。 
* 针对复杂的数据转换，Kafka提供了一些 Stream API, 可以进行流的合并和计算。处理一些数据排序，数据修改，数据状态过滤等。
* Kafka API 对输入、存储，分组提供了高性能的 API 

### 综合处理
* 流式处理、消息处理内容组合放置到一起。使得 Kafka
* 存储历史数据更加便利，以存储未来的数据来进行组合，Kafka 作为流式数据平台和管道来说非常的成功
* 单个数据可以处理历史数据也可以处理，未来的数据，实时订阅的方案能够成为消息队列。周期性的数据加载，
* 流式数据处理能够进行一个数据的实时转换 

### Kafka 安装与生产者消费者创建
```shell script
-- 解压
tar -zxvf kafka_2.12-2.4.0.tgz

-- 启动zk 
./zookeeper-server-start.sh ../config/zookeeper.properties 

-- 启动kafka
./kafka-server-start.sh ../config/server.properties

-- 创建一个主题
./kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic myTopic

-- 向主题中发送消息
./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic myTopic 

-- 创建消费者
./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic myTopic
```
### Zookeeper 说明
* 提供分布式注册发现，分布式协调
* zookeeper 抽象分布式信息

