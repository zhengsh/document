# Kafka 核心概念

### 生产者 (Producer)
* 生产者（Producer）顾名思义，生产者就是产生消息的组件，它的主要工作就是源源不断地生产出消息，然后发送给消息队列。
生产者可以向消息队列发送各种类型的消息，如狭义的字符串消息，也可以发送二进制消息。生产者是消息队列的数据来源，只有通过生产者持续不断地
向消息队列发送消息，消息队列才能不断地处理消息。

### 消费者（Consumer）
* 消费者的概念也是比较容易理解的，所谓消费者，值得是不断消费（获取）消息的组件它获取消息的来源就是消息队列（即 Kafka 本身）。换句话说
生产者不断地向消息队列发送消息，而消费者则不断地从消息队列中获取消息。这里面的消息队列（Kafka）则充当了一个中介的叫绝，连接了生产者与
消费者这两大功能组件，正是从这个意义上来说，借助于消息队列，我们实现了生产系统与消费者系统之间的解耦，使得原本需要两个系统之间紧密联系的
状况编程了两个系统各自针对Kafka进行编程（只需要提前约定好契约即可），这可以使得生产系统完全不需要了解消费者系统的各种信息
（比如说消费者系统的地址、端口号、URL、使用的是 REST 接口还是 RPC 接口等等；反之亦然）。这正是消息队列所提供的一种绝佳的好处，极大降低了
系统之间的耦合关系。

### 代理（Broker）
* 代理这个概念就是消息队列领域中的一个常见的概念。Broker 这个单词原本就是经纪人，比如说房产经纪人、股票经纪人等。 在消息队列领域中，它
指的其实就是消息队列产品本省，比如说在Kafka这个领域下，Broker 其实就是指的就是一个 Kafka Server. 换句话说，我们可以部署一台 Kafka Server
看作是一个Broker, 就是这样简单。那么从流程上来说，生产者就会将消息发送给 Broker, 然后消费者再从 Broker 中拉取消息。

### 主题（Topic）
* 主题是 Kafka 中一个极为重要的概念，首先，主题是一个逻辑上的概念，它用于逻辑上来归类于存储消息本省。多个生产者可以向一个 Topic 发送消息，
同时也可以有多个消费者消费一个 Topic 中的消息。Topic 还有分区与副本的概念， Topic 与消息两个概念之间的密切关系， Kafka 中的每天一条消息
都会归属于一个Topic，而一个 Topic 下面可以有任意数量的消息。正是借助于 Topic 这个逻辑上的概念， Kafka 将各种各样的消息进行了分门别类
，使得不同的消息归属于不同的 Topic ， 这样就额可以很好地实现不同系统的生产者可以向同一个Broker中拉取消息。Topic 是一个字符串。

### 消息（Record）
* 消息是整个队列中最为基础的一个概念，也是最为原子的一个概念，它指的是生产者发送与消息拉取的一个原子事务，一个消息需要关联到一个 Topic 上
表示该消息从属于那个 Topic . 下次由一串字节所构成，其中主要是由key 和 value 两部分组成。key 与 value 本质上都是字节数组。在发送消息时，
我们可以省略key 部分，直接使用value 部分。实际上，他们都是消息的value， 即消息真正的内容本身；key 的主要作用是更具一定的策略，将此
消息发送到指定的分区中，这样就就可以确保包含同一key 值得消息全部都写入到同一个分区中，因此，我们可以得出这样一个结论：对于 Kafka 的消息来说，
真正的消息内容本身是由 value 所承载的。为了提升发送消息的效率和存储效率，生产者会批量将消息发送给 Broker ，并更相应的压缩算法在发生前
堆消息进行压缩。

### 集群（Cluster）
* 集群指的是由多个 Broker 所共同构成的一个整体，对外提供统一的服务，这类于我们在部署系统时都会采用集群的方式来进行。借助于集群的方式。
Kafka 消息队列系统可以实现高可用和容错性，即一台 Borker 挂掉了也不影响真个消息系统的正确运行。集群中的各个 Borker是通过心跳
（Hearbeat）的方式来检测其他机器是否还存活。

### 控制器 （Controller）
* 控制器是集群中的概念。每个集群中会选择出一个 Broker 担任控制器的角色，控制器是 Kafka 集群的中心。 一个 Kafka 集群中，控制器这台
Borker 之外的其他 Borker 会更具控制器的指挥来实现相应的功能。控制器负责管理 Kafka 分区的状态、管理每个分区的副本状态、监听Zookeeper 
中数据的变化并作出相应的反馈等你功能。此外，控制器也类似于主从概念（比如MySQL的主从概念），所有的Borker 都会监听控制器 Leader 的状态，
当 Leader 控制器出现问题或是故障时则重新选择新的控制器 Leader， 这里面设计到一个选举算法的问题

### 消费者组（group name）
* 消费者组与消费者之间关系密切，在Kafka中，多个消费者可以功能构建成一个消费者组，而一个消费者只能从属于一个消费者组。消费者组最为重要的一个
功能就是拓展单播和广播的功能。一个消费者组可以确保其所订阅的Topic的每个分区也只能被从属于该消费组中的唯一一个消费者所消费；如果不同的消费
者组订阅了同一个Topic, 那么这些消费者组之间是彼此独立的，不会受到相互的干扰。因此，如果我们希望一条消息可以被多个消费者所消费， 那就可以将
这些消费者放置到同一个消费者组中，这实际上就是单播的效果，因此，我们可以将消费者组看作是【逻辑上的订阅者】，而物理上的订阅者则是各个消费
者。值得注意的是消费者组是一个非常主要的概念。很多Kafka初学者都会遇到这样一个问题：将系统以集群的形式部署（比如说部署到3台机器或者虚拟机上），
媒体爱机器的指定代码都是完全一样的， 那么在运行时，只会有一台机器会持续不断的收到 Broker 中的消息，而其他机器则一条消息也收不到。究其本质
系统部署时采用了集群部署。因此每一台机器的代码与配置完全一样的。这样，这些机器（消费者）都从属于同一个消费组，既然从属于一个消费组那么，
指挥有一个消费者接收到消息，而其他的消费者则完全接收不到任何消息，即单播的效果。这点需要注意。 
