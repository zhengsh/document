### 原子操作的实现
* 原子(atomic)本意是“不能被进一步分割的最小粒子”，而原子操作(atomic operation)意 为“不可被中断的一个或一系列操作”。在多处理器上实现原子操作就变得复杂。

### 实现原子操作
* 第一个机制是通过总线锁保证原子性
* 第二个机制是通过缓存锁定来保证原子性
* 但是有两种情况下处理器不会使用缓存锁定
  * 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行(cache line)时，则处理器会调用总线锁定。
  * 有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

### Java实现原子操作
* 使用循环CAS实现原子操作
  * JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本 思路就是循环进行CAS操作直到成功为止，以下代码实现了一个基于CAS线程安全的计数器 方法safeCount和一个非线程安全的计数器count。
  * JDK 1.5 开始，JDK的并发包提供了一些支持原子操作的包装类: AtomicBoolean(用原子 方式更新的boolean值)、AtomicInteger(用原子方式更新的int值)和AtomicLong(用原子方式更 新的long值)

* CAS实现原子操作的三大问题
  * 在Java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如 LinkedTransferQueue类的Xfer方法。CAS虽然很高效地解决了原子操作，但是CAS仍然存在三 大问题。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。
    * ABA问题
    * 循环时间长开销大
    * 只能保证一个共享变量的原子操作

* 使用锁机制实现原子操作
  * 锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁 机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环 CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时 候使用循环CAS释放锁。