### ConcurrentHashMap

#### 概述
支持获取的完全并发和更新的所期望可以调整的并发哈希表。此类遵循HashTable 相同的功能规范，并且包括对应于HashTable 的每一个方法的版本. 不过
尽管所有操作都是线程安全的。但获取操作不必锁定， 并且不支持以某种防止所有访问的方式锁定整个表。此类可以通过程序完全与HashTable 进行互操作，
这个取决于线程安全，而与其同步细节无关。

获取操作（包括get）通常不会阻塞，因此，可能与更新操作交迭（包括 put 和 remove）。获取会影响完成的更新操作的结果。 对于这些聚合操作， 比如
putAll 和clear, 并发操作坑你只会影响某些条目的插入和移除，类似的，在创建迭代器/枚举时或自此之后， Iterators, 和 Enumerations 返回在某
一时间点上影响哈希表状态的元素，它们不会抛出java.util.ConcurrentModificationException , 不过，迭代器被设计成每次仅由一个线程使用。
记住，聚合结果状态的方法包括 size、isEmpty、containsValue 通常是在其他线程发生并发更新，否则这些方法的结果只是反映了瞬态，可以是用来
监控或者估算，但是不能用来做程序控制。

当存在太多的冲突（即，具有不同的哈希码但是以表的大小为模录入相同的间隙的秘钥）时， 该表被动态拓展，并且每个保持大致2个bin的预期平均效果
（对应与 0.75 负载因子阈值调整大小）。由于映射被添加和删除，这个平均值可能会有所差异，但是总的来说，这为哈希表保留了普遍接受的时间/空间权衡
然而，调整这个或任何其他类型的散列表可能是相对较慢的操作。 如果可能，最好提供一个尺寸评估作为可选的initialCapacity 构造函数参数， 附加
可选的loaderFactor 构造函数提供另外的手段，通过制定在计算给定数量的元素时要分配的空间量时使用的表密集度来制定初始容量。此外，为了与此类
的先前版本兼容，构造函数可以选择制定预期的concurrencyLevel 作为内部大小调整的附件提示， 请注意，使用完全相同的许多键hashCode()是降低
任何哈希表的hashCode的一种可靠的方法。为了改善影响， 当按键为Comparable 时， 该类可以使用键之间的比较顺序来帮助打破关系。

创建一个投影的ConcurrentHashMap 可以（使用被创建的newKeySet() 或 newKeySet(int)）, 或观察（使用 keySet(Object) 获取所有的键）,
并且被映射的值是（可能瞬时）不使用或全部相同的映射值。

ConcurrentHashMap 可以通过使用 LongAdder 值并通过 computeIfAbsent 进行初始化，将其作为一个可缩放的频率映射（直方图或多集的形式），
例如：向 ConcurrentHashMap<String, LongAdder> freqs 添加计数， 可以使用freqs.computeIfAbsent( k-> new LongAdder).increment()

此类及视图和迭代器实现所有的可选方法Map 和 Iterator 接口

**像 HashTable 但不像 HashMap, 这个类不允许null的作用或键值。**

ConcurrentHashMaps 支持一组顺序和并行批量操作, 与大多数的 Stream 方法不同， 他们被设计为安全且经常频繁的使用， 即使是由其他线程同时更新的映射
例如： 当计算共享注册表中的值的快照摘要时。 有三种操作，每种具有四种形式， 接受键、值，条目和（键、值）参数和/或返回值的函数。由于
ConcurrentHashMap 的元素不以任何特定的方式排序， 并且可能会在不同的并行执行中以不同的顺序进行处理，因此提供的函数的正确性不应取决于任何排序
也不应该依赖于可能瞬时变化的任何其他对象或值计算进行中; 除了每一个行动， 理想情况下都是无副作用的。 对Map.Entry 对象的批量操作不支持方法setValue

* forEach: 每一个元素执行给定的操作, 变量形式在执行操作之前对每个元素应用给定的变换。 
* search:  返回在每个元素上应用给定函数的第一个可用非空结果; 当找到结果时跳过进一步的搜索。
* reduce: 累积每一个元素， 提供的减少功能不能依赖于排序（更正式地，它应该是关联的交换）。 有五种辩题：
    * 平原减少（由于没有相应的返回类型，因此（key, value）函数参数没有这种方法的形式）
    * 映射的减少累积了应用于每个元素的给定函数的结果
    * 使用给定的基础值减少标量, double , int 。
    
这些批量操作接受一个 parallelismThreshold 参数， 如果估计当前集合大小小于给定阈值，则方法惊醒一次进行。使用Long.MAX_VALUE. 的值
Long.MAX_VALUE 抑制所有的并行性。使用1的值可以通过划分足够的子任务来完全利用与所有并行计算的ForkJoinPool,commonPool() 来实现最大并行度。
通常，您最初将选择其中一个极值然后测量使用中间值之间的新跟那个，从而降低开销与吞吐量之间的关系。

批量操作的兵法属性遵循ConcurrentHashMap的并发属性：从get(key) 返回任何非空结果和香瓜尼的访问方法与相关的擦汗如或更新都有一个发生之前的关系。
任何批量操作的结果都反映了这些每个元素关系组成（但是除非以某种方式已知是静态的，它并不一定是相对于整个地图的原子）相反，因为映射中的键和值
从不为控股，所以null作为目前缺乏任何结果的可靠原子指标. 为了保持此属性，null作用所有非标量所见操作的隐含基础。对于double, long, 和int 版本
基础应该是当与任何其他值组合是放回其他值（更正式地，它应该是减少的标识元素）。大多数常见的减少具有这些属性： 例如： 使用计数 o 或者最小值与基准
MAX_VALUE计算和。

作为参数提供的搜索和转换函数应该类似的放回null以指示缺少任何结果（再这种情况下不被使用）。在映射缩减的情况下，这也使得转换可以作为过滤器，如果不
应该组合元素，返回null(或在原始专业化的情况下， 身份基础)。 在使用它们惊醒搜索或者减少操作之前， 您可以通过 "null意味着现在没有任何内容" 
规则下自行构建复合转换和过滤

接受和/或Entry参数的方法维护键值挂链，例如，当找到最大值的密钥时，他们可能是有用的，请注意可以使用 new AbstractMap.SimpleEntry(k, v) 提供
“plain” EntryAbstractMap.SimpleEntry(k, v);

批量操作可能突然完成，抛出在应用程序中遇到的异常。在处理这样的异常时，请注意，其他并发执行的行数也可能引发异常，或者如果没有发生第一个异常，则会这样做。

与顺序形式相比，加速比是常见的，但不能保证。如果并行计算的基础工作比本身开销更大。 则涉及小地图上的简短宫嗯那个的并行操作可能比顺序形式更加慢。
类似的，如果所有处理器正忙于执行不相关的任务，并行化可能不会导致太多的实际并行。

所有任务方法所有参数必须是非空值