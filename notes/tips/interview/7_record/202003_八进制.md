# 2020 面试 重庆八进制

## 自我介绍介绍最近的项目
xxx, xxx ,xx,  

## Redis 有哪些数据类型？
* String，（存储普通的字符串即可）
* Hash ,（key-value 结构，可以用于做POJO的对象存储）
* List （可以用来用来普通的MQ缓冲的场景）,  
* Set （不重复的单列集合）
* Stored Set (排序集合，介于 Hash 和 Set 之间，可以通过 add 和 range 做排行榜)
* Bitmap（位图，可以用于用户消息是否已读）,  
* Hyperloglogs(超级日志，可以模糊统计用户访问信息)， 
* Geospatial indexes （经纬度检索）

## 基于用户配对？
这个题目没有理解清楚，我的解释就是基于经纬度进行网格化，然后定位到指定网格进行用户经纬度匹配。
如果是基于前后题目的考虑不是到是否是想考我 Redis 的 geospatial indexes with radius。

## 常用的几个线程池？
* newFixedThreadPool, 固定长度的线程池
* newSingleThreadExecutor， 单个线程的线程池
* newCachedThreadPool，根据需要来创建线程数量，最大值是 Integer.MaX_VALUE
* newScheduledThreadPool, 支持延迟执行的线程池
* 总之，不建议使用jdk 带的工厂方法创建，最好自己通过 ThreadPoolExecutor 类去自己定义， corePoolSize , maximumPoolSize 等参数。按照经验计算型场景的话建议核心线程数在 CPU 核心数的 2倍左右，这样能够优先的减少线程切换提升性能。

## 对于分布式事务处理方案？
* Alibaba 提供了一个Seata 框架对下面三种模式都支持，但是业务中我们一般使用的是 TCC 较多。
面试过程中回答不是很好，按照seata 官网总结。
* TCC 模式 （业务块进行 prepare， 和 commit ， 和回滚 rollback）
一个分布式的全局事务，整体是一个两阶段的提交模型，全局事务由多个分支组成，分支事务需要满足两阶段提交的模型需求，即分每个分支需要具备自己的：
第一阶段 prepare  行为
第二阶段 commint 或 rollback 行为

* Saga 模式 (事务链条上支持正想的提交和反向的补偿（正冲）操作)
Saga 模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面提供的，一阶段正向服务和二阶段补偿服务都由业务开发方实现。
* AT 两段提交 （在第一阶段提交的时候记录 undolog 用于事务的回滚依据，如果第二阶段失败了，基于undolog反向补偿）

一阶段： 将业务数据和回滚日志以及记录到本地事务中提交，释放本地锁和资源池。
二阶段：
异步提交话，非常快速完成
回滚通过一阶段的日志进行反向补偿
* AT 和 TCC 的区别

   AT 需要基于本地 ACID 事务的关系型数据库支持
TCC 是不依赖于底层的数据资源事务，本质也是吧自定义分支事务纳入全局事务管理器中

## 对于Spring-Cloud-Hystrix 服务熔断/服务降级原理？
* 服务降级：

解决对方服务超时、对方down机或自身处理超时。通过降级策略可以提升用户体验，以及避免后端服务链雪崩。
通常在服务调用方进行，服务降级，通常配合 OpenFeign 通过 fallback 来定降级策略，这里需要注意的是，OpenFeign 默认的超时时间是 1 秒。 需要自定义服务超时时间。以及要开启 OpenFeign 对。Hystrix 的支持。

* 服务熔断：

熔断触发的三个必要条件：
一个统计的的时间周期，滚动窗口（默认10000毫秒）
metrics.rollingStats.timeInMillisesonds
请求次数必须到达一定的数量（默认20次)
ciruitBreaer.requestVolumeThreshold
失败率达到默认失败率（默认50%）
ciruitBreaker.errorThresholdPercentage
服务在时间窗内，到达请求次数、失败率的阈值过后，就会触发服务熔断，服务熔断过后5秒后，服务将进入半开状态，如果有一个请求能够正常请求，那么熔断将会关闭，此时如果无法恢复则进入下一个周期。

## 对于1000个人，100块钱发100个红包如何处理？
进入之前先访问缓存判断是否有库存，没有库存直接返回；如果有库存进入MQ排队，通过分布式锁来保障每次操作的原子性，缓存数据项：红包摘要、剩余数量和领取数量等。
红包拆分规则1. 总金额100，2. 最大领取人数100，3. 每人领取一次。
抽象规则模板，然后装载在迭代器中，执行规则。
计算金额，每次红包最小值，举例 0.01 元，那么在红包金额应该是 100 - （0.01 * 99），进行区间随机即可具体可按照业务控制。
红包发放到红包库中，然后对应库存，红包总额在Redis内存数据库中扣减，领取记录落本地库（考虑跨库时间成本后续操作异步执行）。
用户余额可以通过MQ异步入库，然后通过定时任务进行对账来保障客户余额的正确性。

## Mybatis 获取自增ID，以及One-To-One,  One-To-Many 用法？
* 获取主键ID
通用做法在 Insert 标签下 增加 selectKey 标签
在 selectKey 标签里面增加一个 select last_insert_id() 的执行语句
* One-to-One 、One-To-Many 
在 resultMap => collection 可以设置 一对多
他们都支持嵌套也支持引用别的查询结果集

## MyBatis 中 resultType 和 resultMap 的区别？
* 两个不能同时用
 resultType 制定类的完全限定名称，resultMap 是一个外部的命名引用。

* 当前数据量在1000w左右如何处理？
  * 主导建议分库分表分库分表
  * 分析数据维度通常用时间来划分1天一张表，可以直接业务存储到
  * 这个思路不是很清晰


## 最后要问的问题
* 主营业务，就是主要是做什么的？
* 五险一金是否国家标准？
* 工作氛围如何？