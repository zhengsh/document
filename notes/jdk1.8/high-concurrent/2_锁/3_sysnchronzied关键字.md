### 锁
* 内置锁
* 互斥锁

### 锁和线程安全
* 所有的锁都是互斥的，在同一个时刻，只有一个线程能够获得锁。那么这样就可以保证共享资源的线程安全性。

### sysnchronzied 关键字

* sysnchronzied 修饰普通方法，内置锁的对象是当前类的实例。
* sysnchronzied 修饰静态方法，内置锁的对象是当前类的类实例（Class字节码对象）。
* sysnchronzied 修饰代码块，内置锁的对象就是 sysnchronzied 传入的对象

### 总结
* 任何对象都可以作为锁，那么锁信息有存在什么地方呢？
  * 存在对象头中
* 对象头的信息
  * Mark Word
  * Class Metadata Address
  * Array Length
* 偏向锁
  * 每次获取锁和释放锁会浪费资源
  * 很多情况下，竞争不是由多个线程，而是由一个线程在使用
    * 线程ID
    * Epoch
    * 对象的分代年龄信息
    * 是否是偏向锁
    * 锁标志位
  * 只有一个线程下访问同步代码块的场景

* 轻量级锁
  * 自旋
  * 多个线程可以同时访问

* 重量级锁
  * sysnchronzied