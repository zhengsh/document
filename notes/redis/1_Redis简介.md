# Redis 概述

### redis.io
* Redis 是一个开放源代码（BSD许可）的内存数据库。用作数据存储，缓存和消息代理。它支持数据结构: string, hash, list, set, 
stored sets with range queries(有序集合), bitmaps(位图), hyperloglogs（超级日志）, geospatial indexes with radius 
queries and streams(具有半径查询和流的地理空间索引)。Redis 具有内置的复制，Lua 脚本, LRU 缓存， 事务和不同级别的磁盘持久性，
并通过 Redis Sentinel 和 Redis Cluster 自动分区提供高可用性。 主要作用是用来做数据缓存，将热点数据存储在Redis中可以减少业务流量
对底层数据的访问压力，获得更高的并发和更快的请求响应速度。 

### maxmemory 指令配置
* 使用 maxmemory 配置指令是为了将 Redis 配置为对于数据集使用指定的内存大小。可以使用 redis.conf 文件来设置配置指令，或者在运行期间
使用 CONFIG SET 命令来设置。
* 例如，配置100MB的内存限制，可以在 redis.conf 文件内部使用一下命令。
```
maxmemory 100mb
```
* 设置 maxmemory 代表不限制内存大小，这是64 位系统的默认行为，而32位系统使用3GB作为最大内存限制。
* 当达到指定的内存量时，可以选择不同的行为策略。Redis 可能只返回错误命令因为内存不足导致，或者删除一些旧的数据以便在每次添加新数据的
时候返回指定的限制。

### 驱逐策略
* 
* 

### 驱逐过程
* 驱逐过程的工作方式如下：
  * 客户端运行新命令，从而添加新的数据。
  * Redis 会检查内存使用情况，如果大于使用 maxmemory 限制，则会更具策略将键逐出。
  * 执行新命令，以此类推。
 

### Redis 的 LRU 缓存策略
* 将Redis用作缓存时，当你新增数据的时候， 让它自动回收旧数据是一件很方便的事情。此行为在开发人员社区中是众所周知的，因为它是流行的内存
缓存系统的默认行为。
* LRU(Least Recent Used)是 Redis 唯一支持的回收方法，Redis 的 maxmemory 指令用于将可用内存限制成一个固定大小，还包括Redis 使用的
LRU 算法，这个实际上知识一个近似值。
* 从 Redis 4.0 开始, 引入了新的 LFU （最不常用）的回收策略。

* Redis LRU 的实现过程

* 新的 LFU

### Redis 的 LFU 模式
* 从Redis 4.0 开始，可以使用新的 LFU (Least Frequently Used) 驱逐策略。在某些情况下，此模式可能会更好地工作（提供更好的命中率/未命中率），
因为使用LFU Redis 会尝试跟踪 key 的访问频率，因此，极少使用的 key 会被驱逐，而经常使用的 key 则有较高的机会保留在内存中。
* 如果您认为在 LRU，最近访问过但实际上几乎从未请求过的项目不会过期，因此风险在于驱逐将来有可更高机会请求的key. LFU 没有这个为，通常更
应该适应不同的访问策略。
* 要配置 LFU 策略，可以通过以下的方式：
  * volatile-lfu 使用具有到期的 key 在触发 LFU 中驱逐
  * allkeys-lfu 使用近似的 LFU 退出任何秘钥
* LFU 近似于LRU：它使用一个概率计数器（称为 Morris Counter）,以便仅使用每个对象几个位来估算对象的访问评率，并结合一个衰减周期，从而
使用计数随时间而减少：在某个时候，我们甚至不再希望将秘钥视为过去经常访问的秘钥，因此该算法可以适应访问模式的转变。
* 这些信息的采样方式与LRU 发生的情况类似，以便供使用者选择
* 但是与LRU不同的是，LRU 具有某些可调参数：例如，如果频繁访问的项不再被方位，应该将其降低多快？还可以调整Morris计数器范围，以使算法更好地
适应特定的用例。
* 在默认情况下，Redis 4.0 配置为：
  * 大约在100万请求时会让计数器饱和
  * 每隔1分钟使计数器衰减一次
* 这些是经过用户测试的合理的值，但是用户可以通过设置来选择自己的最佳值。
* 有关如何调整这些参数的说明，可以 redis.conf 在源代码发行版的示例文件中找到，但简要地说，他们是：
```shell script
lfu-log-factor 10
lfu-decay-time 1
```
* 衰减时间是显而易见的，它是采样时返现计数器早于该值应衰减的分钟数。平均值的一个特殊值0：每次扫描是总是使计数器衰减，并且很少使用。
* 计数器对数因子（logarithm factor）会更改要使频率计数器（frequency counter), 频率计数器在 0-255 范围内，因数越高，为了达到最大值
需要更多的访问。更具下表 ，叙述月底，计数器的分辨率月底，
+--------+------------+------------+------------+------------+------------+
| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
+--------+------------+------------+------------+------------+------------+
| 0      | 104        | 255        | 255        | 255        | 255        |
+--------+------------+------------+------------+------------+------------+
| 1      | 18         | 49         | 255        | 255        | 255        |
+--------+------------+------------+------------+------------+------------+
| 10     | 10         | 18         | 142        | 255        | 255        |
+--------+------------+------------+------------+------------+------------+
| 100    | 8          | 11         | 49         | 143        | 255        |
+--------+------------+------------+------------+------------+------------+


### 名词解释

* 位图(bitmaps)，位图不是时机的数据类型，而是在 String 类型的基础上定义的一组面向位的操作。由与字符串是二进制安全 Blob, 并且最大长度为 512MB，
因此他们适合设置多达 1L << 32 不同的位。
  * 操作分为两类: 固定时间的单个位操作（如将一个位设置为1或者0获取其值），以及对位组的操作，例如计算给定范围内设置的位的数量（例如：人口统计）。
  * 位图的最大优点之一是，他们在存储信息时通常可以节省大量空间。例如，在以增量用户ID不同的系统中，仅适用 512MB内存就可以记住40亿用户的，
  一位信息（例如：知道用户是否要接受新闻通讯）。
  适用 SETBIT 和 GETBIT 命令设置检索位:
  ```shell script
  localhost:6379> setbit key 10 1
  (integer) 1
  localhost:6379> getbit key 10
  (integer) 1
  localhost:6379> getbit key 11
  (integer) 0
  ```
  * 所叙SETBIT 命令采用作为第一个参数的比特数，作为第二个参数的值设置所表述位，其为1或0的命令放大字符串，如果寻址位是当前字符串长度之外。
  * GETBIT 知识返货指定索引处的位的值。超出范围的位（寻址超出存储在目标键中的字符串长度的位）始终被视为零。
  在位组上有三个命令
    * BITTOP在不同的字符串之间执行按位运算。提供运算符为 AND，OR，XOR和NOT。
    * BITCOUNT执行填充计数，报告设置为1的位数
    * BITTOPS查找指定值的0或1的第一位
  * 无论BITOPS和BITCOUNT 能够与字符串的字节范围进行操作，而不是该字符串的整个长度运行，一下是BITCOUNT调用的一个简单示例:
  ```shell script
  localhost:6379> setbit key 0 1
  (integer) 0
  localhost:6379> setbit key 100 1
  (integer) 0
  localhost:6379> bitcount key
  (integer) 2
  ```
  * 位图的常见用例是：
    * 各种实时分析。
    * 存储对象ID相关的空间高效且高性能的 boolean 信息。
  * 例如，假设您想知道网站用户每天访问量最长的时间。您从0开始计算天数，即从您公开网站的那一天开始，并在用户每次访问该网站时对SETBIT
  进行设置。作为索引，您只需用当前的unix时间，减去初始偏移量。然后除以一天中的秒数（通常 3600 * 24）。
  * 这样，对于每个用户，您都有一个小的字符串，其中包含每天的访问信息，使用BITCOUNT， 可以轻松获得给定用户访问网站的天数，而只需几个BITTOPS
  调用，或者仅获取和分析客户端你的位图，就可以轻松计算出登录次数最多的用户。
  * 位图很容易分成多个键，例如，为了分片数据集，并且应为通常最好避免使用大键。要在不同的key上拆分位图，而不是将所有的位都设置为key, 一个
  简单的策略就是为每个Key存储M位，并使用来获取KEY名称，使用获取 bit-number/M 第N位bit-number MOD M。
  
* HLL(HyperLogLog), Redis 在 2.8.9 版本添加了 HyperLogLog 结构。 Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，
在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定的、并且很小的。
  * 在Redis 里面，每个HyperLogLog 键只需要花费 12kb 内存，就可以计算出进 2^64 个数不停元素的基数。这个计算基数是，元素越多耗费内存
  就越多的集合形成鲜明对比。
  * 但是，因为 HyperLogLog 只会更具输入元素来计算基数，而不会存储输入元素本省，所以 HyperLogLog 不能像集合那样， 返回输入的各个元素。
  * 基数，比如数据集合 {1, 3, 5, 7, 5, 7, 8}，那么这个数据集基数集为 {1, 3, 5, 7, 8}, 基数（不重复元素）为5。基数估计就是在误差
  可接范围内，快速计算基数。
 
